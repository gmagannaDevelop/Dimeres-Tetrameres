---
title: "Analyse Comparative des Surfaces"
author: "Anthony Boutard, Gustavo Magaña López"
date: "21/04/2021"
output: 
  pdf_document:
    latex_engine: xelatex
    extra_dependencies: ["amsmath"]
    toc: yes
    toc_depth: '3'
  html_document:
    toc: yes
    toc_depth: 3
    df_print: paged
---

```{r setup, include=FALSE}
here::i_am("notebooks/ancestrales_vs_recentes.Rmd")
library(here)
library(foreach)
library(parallel)
library(iterators)
library(ggplot2)
library(dplyr)
library(stringr)
library(magrittr)
library(caret)
library(MLeval)
source(here("src/pretty_tables.R"))
knitr::opts_chunk$set(echo = F, warning = F, message = F, cache = T)
```

```{r read_files, message=F}
# Create a list of files to be read 
clean_df <- function(df){
  df %>% dplyr::select(-X1, -X5, -X7, -X8, -X9, -X10, -X12, -X13) %>% 
    dplyr::rename(
      `atom number` = X2,
      atom = X3,
      residue = X4,
      `residue number` = X6,
      type = X11
    ) %>% 
      group_by(`residue number`) %>% 
        summarise(residue = unique(residue), type = unique(type))
}

.interface_dir <- here("assets/Dim_Tet_interfaces")

csv_interfaces <- 
  list.files(.interface_dir, pattern = "*.csv", full.names = T)

names(csv_interfaces) <- 
  list.files(.interface_dir, pattern = "*.csv") %>% 
  purrr::map_chr(~ stringr::str_replace(.x, pattern = "_inter.csv", ""))

interfaces <-
  csv_interfaces %>% purrr::map(~ readr::read_csv(.x, col_names = F)) %>% 
  purrr::map(~ clean_df(.x))

```


```{r func.def}
type.counts.ls <- interfaces %>% purrr::map(~ dplyr::count(.x, type))
type.counts.df <- bind_rows(type.counts.ls, .id = "protein")
```


```{r pooled.counts}
type.proportions.df <- type.counts.df %>% 
  with_groups(c(protein), mutate, np = n / sum(n)) %>% 
  mutate(
    type = case_when(
      type == 0 ~ "non-interface",
      type == 1 ~ "ancestral",
      type == 2 ~ "recent"
    )
  ) %>% rename(size = np) 
```

```{r discriminator}
homomers <- type.proportions.df %>% group_by(protein) %>% 
  summarise(ntype = length(unique(type)))

dimers.names <- homomers %>% filter(ntype == 2) %>% 
  select(protein) %>% unlist(use.names = F)

tetramers.names <- homomers %>% filter(ntype == 3) %>%
  select(protein) %>% unlist(use.names = F)

dimers <- type.proportions.df %>% filter(protein %in% dimers.names)
tetramers <- type.proportions.df %>% filter(protein %in% tetramers.names)
```


```{r densities.by.type}
tetramers %>% 
    ggplot(aes(x=size,  colour=type)) + 
      geom_histogram(
        aes(y = after_stat(density)), fill="white",
      ) +
        geom_density(aes(fill = type), alpha=.2) + 
    ggtitle("Distribution des tailles relatives selon le type")
```


```{r histograms.by.type}
tetramers %>% 
    ggplot(aes(y=size, x=type, colour=type)) + geom_boxplot() +
    ggtitle("Distribution des tailles relatives selon le type")
```

```{r ancestral.size}
ancestral.surface.df <- type.proportions.df %>% filter(type == "ancestral") %>% 
  mutate(
    protein_type = case_when(
      protein %in% dimers.names ~ "dimer",
      protein %in% tetramers.names ~ "tetramer"
    )
  ) 

ancestral.surface.df %>% 
  ggplot(aes(x=size,  colour=protein_type)) + 
      geom_histogram(
        aes(y = after_stat(density)), fill="white",
      ) +
        geom_density(aes(fill = protein_type), alpha=.2) + 
    ggtitle("Proportion de la taille de l'interface ancestrale")
```

```{r boxplots.2}
ancestral.surface.df %>% 
    ggplot(aes(y=size, x=protein_type, colour=protein_type)) + 
    geom_boxplot() +
    ggtitle("Distribution des tailles relatives selon le type")
```

```{r antho}
interface1.tetrameric <- ancestral.surface.df %>% 
  filter(protein_type == "tetramer") %>% select(size) %>% unlist(use.names = F)
interface1.dimeric <- ancestral.surface.df %>% 
  filter(protein_type == "dimer") %>% select(size) %>% unlist(use.names = F)
t.test(interface1.dimeric, interface1.tetrameric)
```

```{r newdata}
metrics <- readr::read_csv(here("assets/tetrametic_metrics.csv"))
```

```{r separate.annotate.join}
ancestral.cov.df <- metrics %>% select(contains("interface1"), protein) %>% 
  rename_all(~ str_trim(str_remove_all(.x, "interface1"))) %>% 
    mutate(interface = "ancestral") %>% select(interface, everything())

recent.cov.df <- metrics %>% select(contains("interface2"), protein) %>% 
  rename_all(~ str_trim(str_remove_all(.x, "interface2"))) %>% 
    mutate(interface = "recent") %>% select(interface, everything())

annotated.df <- rbind(ancestral.cov.df, recent.cov.df) %>% 
  mutate(interface = factor(interface)) %>% 
    rename(size = `relative size`) %>% 
      select(interface, protein, everything())

annotated.reg.df <- annotated.df %>% select(-protein)
```

```{r consurf}
consurf <- metrics %>% select(starts_with("consurf")) %>% 
  rename(
    interface1 = `consurf interface1`, 
    interface2 = `consurf interface2`, 
  ) %>% 
  reshape2::melt() %>% rename(Interface = variable, `Consurf score` = value) %>% 
  mutate(
    Interface = case_when(
      Interface == "interface1" ~ "ancestral",
      Interface == "interface2" ~ "recent"
    )
  )

consurf %>%
    ggplot(aes(y=`Consurf score`, x=Interface, colour=Interface)) + 
    geom_boxplot() +
    ggtitle("Score Consurf par type d'interface")
```

```{r test.consurf}
consurf.ancestral <- consurf %>% filter(Interface == "ancestral") %>% 
  select(`Consurf score`) %>% unlist(use.names = F)
consurf.recent <- consurf %>% filter(Interface == "recent") %>% 
  select(`Consurf score`) %>% unlist(use.names = F)
t.test(consurf.recent, consurf.ancestral)
```



`r annotated.reg.df %>% select(-interface) %>%  describe() %>%   knitr::kable()`

```{r aa.composition}
annotated.reg.df %>% select(interface, hydrophobic, polar, charged) %>% 
  reshape2::melt() %>% rename(`AA type` = variable, proportion = value) %>% 
    ggplot(aes(x=`AA type`, y=proportion, colour=interface)) +
      geom_boxplot()
```

```{r pca.data.frame}
pca.tbl <- annotated.df %>% 
  mutate(
    interface = case_when(
      interface == "ancestral" ~ "int1",
      interface == "recent" ~ "int2"
    )
  ) %>% tidyr::unite(protein_type, c("protein", "interface"))

pre.pca.df <- pca.tbl %>% select(-protein_type) %>%  as.data.frame()
row.names(pre.pca.df) <- unlist(pca.tbl$protein_type)
pca.df <- scale(pre.pca.df)

pca.interfaces <- pca.tbl %>% 
  mutate(
    interface = if_else(str_detect(protein_type, "int1"), "ancestral", "recent")
  ) %>% select(interface) %>% unlist(use.names = F)
```

```{r pam.maybe}
pca_mod <- prcomp(pca.df)  # compute principal components


pca.var.props <- 
  100 * as.data.frame(summary(pca_mod)$importance)["Proportion of Variance", ]
pc1.var <- as.numeric(pca.var.props["PC1"]) %>% round()
pc2.var <- as.numeric(pca.var.props["PC2"]) %>% round()


# Data frame of principal components ----------------------
df_pc <- data.frame(pca_mod$x, Interface=pca.interfaces)  
df_pc_ancestral <- df_pc[df_pc$Interface == "ancestral", ] 
df_pc_recent <- df_pc[df_pc$Interface == "recent", ]  

# Plot ----------------------------------------------------
ggplot(df_pc, aes(PC1, PC2, col=Interface)) + 
  geom_point(aes(shape=Interface), size=2) +   # draw points
  labs(title="Visualisation des clusters par type d'interface", 
       subtitle="par analyse en composants principaux",
       caption="Dim_Tet_interfaces") + 
  coord_cartesian(xlim = 1.2 * c(min(df_pc$PC1), max(df_pc$PC1)), 
                  ylim = 1.2 * c(min(df_pc$PC2), max(df_pc$PC2))) +
  ggalt::geom_encircle(data = df_pc_ancestral, aes(x=PC1, y=PC2)) + 
  ggalt::geom_encircle(data = df_pc_recent, aes(x=PC1, y=PC2)) +
  labs(
    x = glue::glue("CP1 (~{pc1.var} %)"),
    y = glue::glue("CP2 (~{pc2.var} %)")
  )
```



```{r le.plot, eval=F}
GGally::ggpairs(annotated.reg.df, aes(colour=interface))
```

```{r regression}
# regression naive
m1.glm <- glm(interface ~ ., data = annotated.reg.df, family = binomial)
summary(m1.glm)
```

```{r k.fold.explore, eval=F, echo=F, include=F}
# verify if folds are correctly balanced.
tryfold <- createFolds(annotated.reg.df$interface, k = 3)
#tryfold <- createFolds(annotated.reg.df$interface, k = 3, returnTrain = T)

annotated.reg.df %>% mutate(i = 1:n()) %>% 
   filter(i %in% tryfold$Fold2) %>% 
    group_by(interface) %>% summarise(counts = n())

# TODO : implement cross-validation myself.
```


```{r regression.cv}

# define training control
train_control <- trainControl(
  method = "cv", 
  number = 3,
  classProbs = T,
  savePredictions = T,
  summaryFunction = twoClassSummary
)

# train the model on training set
model <- train(
  interface ~ ., data = annotated.reg.df,
  trControl = train_control,
  method = "glm", family=binomial(),
  metric = "Accuracy"
)

model2 <- train(
  interface ~ ., data = annotated.reg.df,
  trControl = train_control,
  method = "glm", family=binomial(),
  metric = "Kappa"
)

model3 <- train(
  interface ~ ., data = annotated.reg.df,
  trControl = train_control,
  method = "glm", family=binomial(),
  metric = "ROC"
)


## print cv scores
print(model)
#
#
#res <- evalm(model)
#
### get ROC
#res$roc
```
